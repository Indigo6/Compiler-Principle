# 编译原理实验五：翻译汇编

## 一、实验目的：

######①在此前实验基础上，编写翻译方案，将给定的PL0代码翻译为汇编码；

######②跑过所有case，拿满100分。

## 二、实验环境：

Win10系统下虚拟机VMware搭载的Ubuntu16.04系统。

## 三、实验内容：

######①任务分配：

​	严格来说，本次实验中要求的print语句功能扩展应该作为上一次实验的必做部分，组长江学强同志于是一马当先地把print语句的语法分析部分照着先前代码完成了，我们主要分配语义分析和翻译部分的工作。

​	分配思路和先前相近，江学强负责定义、语句、返回参数部分内容，方林负责语句、条件、while部分内容，我负责运算式、表达式、参数传递部分内容。基于我们已经完成的语法分析，在分析过程中加以相应的栈操作，即可灵活运用给定的栈类型虚拟机，通过汇编指令完成函数任务。

​	不过真正工作的时候，我们三人往往每个部分都会去单步调试。

###### ②实现流程和个人工作：

​	首先我们一起对先前设计的语法分析部分进行debug，这是因为助教提供的test case与我们此前预想的略有不同。例如，在扩展函数传参功能后，我们默认所有PL0的函数按照C语言标准，需要带括号，若无参数则带空括号；而case中的写法则是函数在无参数时无括号，有参数时才有括号，因此我们需要修改函数部分和表达式部分对应的产生式和follow集。如果上一次实验中助教给定几个示例程序或规定扩展格式，这部分形式上多余的工作可能可以省下来。

​	之后，我们一同商讨汇编码的翻译方案。根据给定的虚拟机指令，我们需要对栈进行维护，借助虚拟机提供的内存空间进行变量、常量的存储，通过jmp指令跳转实现while、elif、函数等功能。由于需要回填，我们决定设置一个结构体数组codes，把生成的汇编程序每一行存入到codes[i]中，维护一个全局迭代器offset来对codes进行灵活的操作，在完成所有分析后保证能将codes[i]中每一条指令所需信息填写完，再输出到asm文件中。

​	在词法分析部分，我们维护了一个变量表，给读取到的id、num依据不同类型分配存储空间（memory地址）、标号、赋值等。翻译时，我们在“定义语句”部分为上表提供必要信息，在“调用”（如表达式、call id等）时根据id查找表中信息，完成变量和常量的信息存储调用功能。

​	对于函数、elif、while语句，我们利用栈结构和jmp指令实现。以调用函数为例，每次进行到call id，我们先进行现场快照，快照的思路是将当前与id level相同的变量和常量依次压入栈中；再将当前汇编代码行数（+1）压入，用于函数执行结束以后跳回来；之后把函数的各个参数压入栈内；最后jmp到函数开头对应汇编代码的行号，这一行号可以通过查询变量表获得。而函数中，首先逐个将栈中参数取出，存入到形参地址里；之后进行函数内部的一系列操作；最后返回值入栈、调整栈顶次序、利用jmp指令跳回来。实现的函数可以完成递归、重复定义等功能。

​	表达式、运算式等语句，则直接在语法分析的基础上加以相应翻译即可，例如加法只需将LD PUT ADD之类的指令组合放在适当位置。翻译后，表达式（expression）的分析将最终给栈顶压入一个数值，其中蕴含了各种加减乘除运算、调用函数作为运算数的操作以及括号匹配等问题，经过我们耐心的分析和细致的debug，均得以解决。

​	个人工作：参与整体方案的讨论和不断完善，完成表达式、运算、参数传递等部分的翻译，辅助完成函数定义、各种跳转相关语句等部分的翻译，反复遍历27个case，通过人脑+纸笔跑汇编以及python模拟器跑汇编等方式debug。

###### ③遇到的问题和解决方案：

​	问题一：减法、除法、返回值等操作都需要调整栈顶元素次序？设计时指定一块给定内存，专门用于栈顶元素次序调整。

​	问题二：递归调用函数时需要快照保存现场，而p函数内部定义q函数后再调用q时不需要保存q中现场？读取到id时根据id的level与当前level进行比较，再决定是否对该部分进行现场保护。

​	问题三：自己写了模拟器实现栈操作，在其中进行测试，发现由于未扩展数组功能和逻辑功能，共5个advanced的case无法完成（16,17,18,19,26），其余所有case结果均与out一致，理论得分156-5*8=116分，但虚拟机最终得分只有102分？

​	百思不得其解。

## 四、小结

​	本次实验相较先前的实验感觉更加有趣，也许是因为多了独特的跑分机制，看着分数变化：4，32，54，70，86，94，102，每一次提升都包含着我们不懈的单步调试和错误修正。总体而言，我们的超简洁版编译器终于磕磕碰碰诞生了，虽然也许还有着某些尚未被我们抓到的bug，但终于能够正常工作。在实现功能的每一环节中，我们对编译课本上的相关知识有了更深入的理解，也学到了许许多多团队协作技巧和单步调试秘技，收获匪浅。没有实现逻辑运算和数组功能，算是稍微留有一些遗憾，希望将来有机会能写出更完备、更优雅的编译器。

​	

